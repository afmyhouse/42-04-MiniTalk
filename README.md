# 42-04-MiniTalk
## Subject

### Mandatory Part
#### Mandatory task list
You must create a communication program in the form of a client and a server.
- [ ] The server must be started first. After its launch, it has to print its PID.
- [ ] The client takes two parameters: the server PID, the string to send (./client PID_NUMBER "string to send")
- [ ] The client must send the string passed as a parameter to the server.
- [ ] Once the string has been received, the server must print it.
- [ ] The server has to display the string pretty quickly. 
        _Quickly means that if you think it takes too long, then it is probably too long._
        _1 second for displaying 100 characters is way too much!_
- [ ] Your server should be able to receive strings from several clients in a row without needing to restart.
- [ ] The communication between your client and your server has to be done only using UNIX signals.
        _You can only use these two signals: SIGUSR1 and SIGUSR2._
        _Linux system does NOT queue signals when you already have pending signals of this type! Bonus time?_

### Bonus part
#### Bonus task list:
- [ ] The server acknowledges every message received by sending back a signal to the client.
- [ ] Unicode characters support! **UTF-8**

## Evaluation
The bonus part will only be assessed if the mandatory part is PERFECT. 
Perfect means the mandatory part has been integrally done and works without malfunctioning. 
If you have not passed ALL the mandatory requirements, your bonus part will not be evaluated at all.### Project instructions

## Project Specific Instructions
- [ ] Name your executable files _client_ and _server_
- [ ] You have to turn in a Makefile which will compile your source files. It must not relink.
- [ ] You can definitely use your libft.
- [ ] You have to handle errors thoroughly. 
- [ ] In no way your program should quit unexpectedly (segmentation fault, bus error, double free, and so forth).
- [ ] Your program mustn’t have memory leaks.
- [ ] You can have one global variable per program (one for the client and one for the server), but you will have to justify their use.
- [ ] In order to complete the mandatory part, you are allowed to use the following functions: 


## Allowed Functions (manual)
- [`write`](https://man7.org/linux/man-pages/man2/write.2.html)
- [`ft_printf`](https://github.com/afmyhouse/42-01-ft_printf) and any equivalent YOU coded
- [`signal`](https://man7.org/linux/man-pages/man2/signal.2.html)
- [`sigemptyset & sigaddset`](https://man7.org/linux/man-pages/man3/sigsetops.3.html)
- [`sigaction`](https://man7.org/linux/man-pages/man2/sigaction.2.html)
- [`kill`](https://man7.org/linux/man-pages/man2/kill.2.html)
- [`getpid`](https://man7.org/linux/man-pages/man2/getpid.2.html)
- [`malloc`](https://man7.org/linux/man-pages/man3/free.3.html)
- [`free`](https://man7.org/linux/man-pages/man3/free.3.html)
- [`pause`](https://man7.org/linux/man-pages/man2/pause.2.html)
- [`sleep`](https://man7.org/linux/man-pages/man3/sleep.3.html)
- [`usleep`](https://man7.org/linux/man-pages/man3/usleep.3.html)
- [`exit`](https://man7.org/linux/man-pages/man3/exit.3.html)

## Intro to signals
### What are signals in LINUX?
Signals are standardized messages sent to a running program to trigger specific behavior, such as quitting or error handling. They are a limited form of inter-process communication (IPC), typically used in POSIX-compliant operating systems. \
When a signal is sent. the operating system interrupts the target process normal flow of executing to deliver the signal. Execution can be interrupted during any non-atomic instruction. If the process has previously registered a signal handler,  that routine is executed. Otherwise, the default signal handler is executed. \
A signal is an event generated by the UNIX and Linux systems in response to some condition. Upon receipt of a signal, a process may take action. \
A signal is just like an interrupt; when it is generated at the user level, a call is made to the kernel of the OS, which then acts accordingly. \
### What types of signals are there?
There are two types of signals:
- __Maskable__: signals which can be changed or ignored by the user (e.g., Ctrl+C)
- __None-Maskable__: Signals which cannot be changed or ignored by the user. These typically occurs when the user is signaled for non-recoverable hardware errors.

#### How to handle signals
Signal handlers can be installed with the system calls :
-- [`signal(2)`](https://man7.org/linux/man-pages/man7/signal.7.html) 
or
-- [`sigaction(2)`](https://man7.org/linux/man-pages/man2/sigaction.2.html) 

If a signal handler is not installer for a particular signal, the default handler is user. Otherwise the signal is intercepted and the signal handler is invoked. \
The signals are defined in the header file signal.h as a macro constant. Signal name has started with a “SIG” and followed by a short description of the signal. So, every signal has a unique numeric value. Your program should always use the name of the signals, not the signals number. The reason is signal number can differ according to system but meaning of names will be standard. \
The macro NSIG is the total number of signal defined. The value of NSIG is one greater than the total number of signal defined (All signal numbers are allocated consecutively).

The following is a list of all signals with names as in the include file `<signal.h>`:

```
    No    Name         Default Action       Description
     1     SIGHUP       terminate process    terminal line hangup
     2     SIGINT       terminate process    interrupt program
     3     SIGQUIT      create core image    quit program
     4     SIGILL       create core image    illegal instruction
     5     SIGTRAP      create core image    trace trap
     6     SIGABRT      create core image    abort program (formerly SIGIOT)
     7     SIGEMT       create core image    emulate instruction executed
     8     SIGFPE       create core image    floating-point exception
     9     SIGKILL      terminate process    kill program
     10    SIGBUS       create core image    bus error
     11    SIGSEGV      create core image    segmentation violation
     12    SIGSYS       create core image    non-existent system call invoked
     13    SIGPIPE      terminate process    write on a pipe with no reader
     14    SIGALRM      terminate process    real-time timer expired
     15    SIGTERM      terminate process    software termination signal
     16    SIGURG       discard signal       urgent condition present on socket
     17    SIGSTOP      stop process         stop (cannot be caught or ignored)
     18    SIGTSTP      stop process         stop signal generated from keyboard
     19    SIGCONT      discard signal       continue after stop
     20    SIGCHLD      discard signal       child status has changed
     21    SIGTTIN      stop process         background read attempted from control terminal
     22    SIGTTOU      stop process         background write attempted to control terminal
     23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))
     24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))
     25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))
     26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))
     27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))
     28    SIGWINCH     discard signal       Window size change
     29    SIGINFO      discard signal       status request from keyboard
     30    SIGUSR1      terminate process    User defined signal 1
     31    SIGUSR2      terminate process    User defined signal 2
```

## Resources
- [Examine and Change Signal Action](https://www.ibm.com/docs/en/i/7.2?topic=ssw_ibm_i_72/apis/sigactn.html)
- [Signal (IPC)](https://en.wikipedia.org/wiki/Signal_(IPC))
- [Process (computing)](https://en.wikipedia.org/wiki/Process_(computing))
- [Thread (computing)](https://en.wikipedia.org/wiki/Thread_(computing))
- [How to use signal handlers in C](https://linuxhint.com/signal_handlers_c_programming_language/)
- [signals](https://people.kth.se/~johanmon/ose/assignments/signals.pdf)
- [How to Write Advanced Signal Handlers in UNIX](https://www.oracle.com/technical-resources/articles/it-infrastructure/dev-signal-handlers-studio.html)
- [What is the difference between sigaction and signal?](https://stackoverflow.com/questions/231912/what-is-the-difference-between-sigaction-and-signal)
- [What is sigaction in C?](https://jameshfisher.com/2017/01/13/c-sigaction/)




